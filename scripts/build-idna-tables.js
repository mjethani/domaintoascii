/*
 * Copyright (c) 2021 Manish Jethani
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

import { writeFileSync } from 'fs';
import https from 'https';

let idnaMappingTableURL = 'https://unicode.org/Public/idna/14.0.0/IdnaMappingTable.txt';
let unicodeDataURL = 'https://unicode.org/Public/14.0.0/ucd/UnicodeData.txt';

function download(url) {
  let read = message => new Promise(resolve => {
    let buffer = Buffer.from([]);

    message.on('data', chunk => {
      buffer = Buffer.concat([ buffer, chunk ]);
    });

    message.on('end', () => {
      resolve(buffer.toString('utf8'));
    });
  });

  return new Promise((resolve, reject) => {
    https.get(url, message => {
      let { statusCode } = message;

      if (statusCode !== 200)
        reject(new Error(`Download failed for ${url} with HTTP status code ${statusCode}.`));
      else
        resolve(read(message));
    })
    .on('error', reject);
  });
}

let [ idnaMappingTable, unicodeData ] = await Promise.all([
  download(idnaMappingTableURL),
  download(unicodeDataURL)
]);

// https://unicode.org/reports/tr46/
// UseSTD3ASCIIRules=true
// Non-transitional

let parsed = {
  disallowed: [],
  ignored: [],
  mapped: [],
  marks: []
};

{
  for (let line of idnaMappingTable.split('\n')) {
    line = line.replace(/#.*/, '');
    if (line === '')
      continue;

    let [ codePoint, spec, value ] = line.split(';').map(x => x.trim());

    switch (spec) {
      case 'disallowed':
      case 'disallowed_STD3_mapped':
      case 'disallowed_STD3_valid': {
        let [ start, end = start ] = codePoint.split('..');
        parsed.disallowed.push([ start, end ]);
        break;
      }

      case 'ignored': {
        let [ start, end = start ] = codePoint.split('..');
        parsed.ignored.push([ start, end ]);
        break;
      }

      case 'mapped': {
        // The code in idna.c can handle a maximum of 6 code points per entry.
        if (value.split(/\s+/g).length > 6)
          throw new Error(`Too many code points for ${codePoint}`);

        let [ start, end = start ] = codePoint.split('..');

        for (let i = parseInt(start, 16), n = parseInt(end, 16); i <= n; i++) {
          let key = i.toString(16).toUpperCase().padStart(4, '0');
          parsed.mapped.push([ key, value ]);
        }

        break;
      }

      case 'valid':
      case 'deviation':
        break;

      default:
        throw new Error(`Unknown spec ${spec}`);
    }
  }
}

{
  let lastMarkCodePointNum = NaN;

  for (let line of unicodeData.split('\n')) {
    let [ codePoint, , gc ] = line.split(';', 3);

    if (gc === 'Mn' || gc === 'Me' || gc === 'Mc') {
      let codePointNum = parseInt(codePoint, 16);

      if (codePointNum === lastMarkCodePointNum + 1)
        parsed.marks[parsed.marks.length - 1][1] = codePoint;
      else
        parsed.marks.push([ codePoint, codePoint ]);

      lastMarkCodePointNum = codePointNum;
    }
  }
}

let code = `// Autogenerated using scripts/build-idna-tables.js

// ${idnaMappingTableURL}
// ${unicodeDataURL}

typedef struct {
  uint32_t key;
  uint32_t value[6];
} idna_tables_mapped_entry;

static idna_tables_mapped_entry idna_tables_mapped[] = {
${
  parsed.mapped
  .map(e => `  { 0x${e[0]}, { ${e[1].split(/\s+/g).map(x => '0x' + x).join(', ')} } }`)
  .join(',\n')
}
};

static uint32_t idna_tables_ignored[][2] = {
${parsed.ignored.map(e => `  { 0x${e[0]}, 0x${e[1]} }`).join(',\n')}
};

static uint32_t idna_tables_disallowed[][2] = {
${parsed.disallowed.map(e => `  { 0x${e[0]}, 0x${e[1]} }`).join(',\n')}
};

static uint32_t idna_tables_marks[][2] = {
${parsed.marks.map(e => `  { 0x${e[0]}, 0x${e[1]} }`).join(',\n')}
};
`;

writeFileSync('idna_tables-generated.h', code);
